#!/bin/bash
#
# dictate - toggle voice dictation
#
# First invocation starts recording. Second invocation stops recording,
# transcribes via a local whisper.cpp server, and types the result into
# the active window via clipboard paste (bracketed paste safe for vim).
#
# Usage: dictate [--log] [--raw] [discard|copy|copypaste]
#   --log      Write timing and response data to ~/voice/dictate.log
#   --raw      Skip post-processing, use raw whisper output
#   discard    If recording, stop and discard. If not recording, do nothing.
#   copy       If recording, transcribe and copy to clipboard (no paste).
#              If not recording, start recording.
#   copypaste  (default) If recording, transcribe, copy, and paste.
#              If not recording, start recording.

PIDFILE="${XDG_RUNTIME_DIR:-/tmp}/dictate.pid"
WAVFILE="${XDG_RUNTIME_DIR:-/tmp}/dictate.wav"
NOTIFYFILE="${XDG_RUNTIME_DIR:-/tmp}/dictate.notify"
SERVER="http://127.0.0.1:8178"
LOGFILE="$HOME/voice/dictate.log"
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

LOG=false
RAW=false
ACTION=copypaste
for arg in "$@"; do
    case "$arg" in
        --log) LOG=true ;;
        --raw) RAW=true ;;
        discard|copy|copypaste) ACTION="$arg" ;;
    esac
done

# KDE custom shortcuts launch commands with closed file descriptors.
# wl-copy aborts if stdin/stdout/stderr aren't open. Ensure they exist.
exec 0< /dev/null
exec 1> /dev/null
exec 2> /dev/null

log() {
    if $LOG; then
        printf '%s\n' "$*" >> "$LOGFILE"
    fi
}

notify() {
    # First arg is timeout in ms, rest are passed to notify-send.
    # Replaces the previous notification if one exists.
    local timeout="$1"; shift
    local replace_arg=()
    if [ -f "$NOTIFYFILE" ]; then
        replace_arg=(-r "$(cat "$NOTIFYFILE")")
    fi
    local id
    id=$(notify-send -p -t "$timeout" -a Dictation "${replace_arg[@]}" "$@")
    echo "$id" > "$NOTIFYFILE"
}

now_ms() {
    date +%s%3N
}

# If currently recording, stop and handle action
if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE")" 2>/dev/null; then
    T_START=$(now_ms)

    RECPID=$(cat "$PIDFILE")
    kill -INT "$RECPID"
    # Wait for pw-record to exit and finalize the WAV header.
    # Typically takes <10ms; timeout after 2s as a safety net.
    DEADLINE=$(( $(now_ms) + 2000 ))
    while kill -0 "$RECPID" 2>/dev/null; do
        if [ "$(now_ms)" -gt "$DEADLINE" ]; then
            kill -9 "$RECPID" 2>/dev/null
            break
        fi
        sleep 0.005
    done
    rm -f "$PIDFILE"

    T_STOPPED=$(now_ms)

    # Discard: throw away recording, no transcription
    if [ "$ACTION" = "discard" ]; then
        rm -f "$WAVFILE"
        notify 2000 "Discarded"
        log "--- $(date -Iseconds) [$ACTION] ---"
        log "discarded after $(( T_STOPPED - T_START ))ms"
        log ""
        exit 0
    fi

    notify 10000 "Transcribing..."

    AUDIO_SIZE=$(stat -c%s "$WAVFILE" 2>/dev/null || echo 0)
    # 16kHz × 16-bit × mono = 32000 bytes/sec, plus 44-byte WAV header
    AUDIO_SECS=$(( (AUDIO_SIZE - 44) / 32000 ))

    if ! RESPONSE=$(curl -sf -X POST "${SERVER}/inference" \
        -F "file=@${WAVFILE}" \
        -F "temperature=0.0" \
        -F "response_format=json"); then
        notify 2000 "Error" "Whisper server not reachable"
        rm -f "$WAVFILE"
        log "--- $(date -Iseconds) [$ACTION] ---"
        log "ERROR: whisper server not reachable"
        log ""
        exit 1
    fi

    T_RESPONSE=$(now_ms)

    rm -f "$WAVFILE"

    RAW_TEXT=$(printf '%s' "$RESPONSE" | jq -r '.text // empty')
    if $RAW; then
        TEXT=$(printf '%s' "$RAW_TEXT" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    else
        TEXT=$(printf '%s' "$RAW_TEXT" | python3 "${SCRIPT_DIR}/postprocess") || TEXT="$RAW_TEXT"
    fi

    if [ -n "$TEXT" ]; then
        wl-copy -- "$TEXT"

        if [ "$ACTION" = "copypaste" ]; then
            # Paste via clipboard — the terminal emulator wraps this in
            # bracketed paste escape sequences, so Neovim/vim handle it
            # safely in any mode.
            # Ctrl(29)+Shift(42)+V(47) — raw keycodes required by ydotool 1.0+
            ydotool key 29:1 42:1 47:1 47:0 42:0 29:0
            T_DONE=$(now_ms)
            notify 4000 "Done" "$TEXT"
        else
            # copy: clipboard only, no paste
            T_DONE=$(now_ms)
            notify 4000 "Copied" "$TEXT"
        fi
    else
        T_DONE=$(now_ms)
        notify 2000 "No speech detected"
    fi

    log "--- $(date -Iseconds) [$ACTION] ---"
    log "audio:     ~${AUDIO_SECS}s (${AUDIO_SIZE} bytes)"
    log "stop:      $(( T_STOPPED - T_START ))ms  (kill pw-record + sleep)"
    log "inference: $(( T_RESPONSE - T_STOPPED ))ms  (POST to whisper server)"
    log "done:      $(( T_DONE - T_RESPONSE ))ms  (wl-copy + ydotool)"
    log "total:     $(( T_DONE - T_START ))ms"
    log "raw:       ${RAW_TEXT:-<empty>}"
    log "text:      ${TEXT:-<empty>}"
    log ""
else
    # Not recording — discard is a no-op
    if [ "$ACTION" = "discard" ]; then
        exit 0
    fi

    # Clean up any stale state and start recording
    rm -f "$PIDFILE" "$WAVFILE" "$NOTIFYFILE"
    pw-record --rate 16000 --channels 1 --format s16 "$WAVFILE" &
    PID=$!
    # Detach pw-record from this shell so it isn't killed by SIGHUP when
    # the script exits. The process keeps recording until the next
    # invocation sends it SIGINT.
    disown $PID
    echo $PID > "$PIDFILE"
    notify 0 "Recording..."
    log "--- $(date -Iseconds) [$ACTION] ---"
    log "recording started (pid $PID)"
    log ""
fi
